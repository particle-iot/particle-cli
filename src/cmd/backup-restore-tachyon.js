const CLICommandBase = require('./base');
const QdlFlasher = require('../lib/qdl');
const path = require('path');
const temp = require('temp').track();
const fs = require('fs-extra');
const { getEdlDevices } = require('particle-usb');
const os = require('os');
const { delay } = require('../lib/utilities');
const DEVICE_READY_WAIT_TIME = 5000;

const PARTITIONS_TO_BACKUP = [
	{
		label: 'nvdata1',
		num_partition_sectors: 256,
		physical_partition_number: 0,
		start_byte_hex: '0x8000',
		start_sector: 8
	},
	{
		label: 'nvdata2',
		num_partition_sectors: 256,
		physical_partition_number: 0,
		start_byte_hex: '0x108000',
		start_sector: 264
	},
	{
		label: 'modemst1',
		num_partition_sectors: 768,
		physical_partition_number: 5,
		start_byte_hex: '0x20000',
		start_sector: 32
	},
	{
		label: 'modemst2',
		num_partition_sectors: 768,
		physical_partition_number: 5,
		start_byte_hex: '0x320000',
		start_sector: 800
	},
	{
		label: 'fsg',
		num_partition_sectors: 768,
		physical_partition_number: 5,
		start_byte_hex: '0x620000',
		start_sector: 1568
	},
	{
		label: 'fsc',
		num_partition_sectors: 32,
		physical_partition_number: 5,
		start_byte_hex: '0x920000',
		start_sector: 2336
	}
];

module.exports = class BackupRestoreTachyonCommand extends CLICommandBase {
	constructor({ ui } = {}) {
		super();
		this.ui = ui || this.ui;
		this.firehosePath = path.join(__dirname, '../../assets/qdl/firehose/prog_firehose_ddr.elf');
	}

	async backup({ 'output-dir': outputDir = process.cwd(), 'log-dir': logDir = process.cwd() } = {}) {
		const deviceId = await this._getEDLDeviceId();
		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}
		if (!fs.existsSync(logDir)) {
			fs.mkdirSync(logDir, { recursive: true });
		}

		const partitions = this.partitionDefinitions({ deviceId, dir: outputDir });
		const xmlFile = this.generateXml({ partitions, operation: 'read' });
		const files = [
			this.firehosePath,
			xmlFile
		];

		this.ui.stdout.write(`Backing up NV data from device ${deviceId}...${os.EOL}`);
		const qdl = new QdlFlasher({
			outputLogFile: path.join(logDir, `tachyon_backup_${Date.now()}.log`),
			files: files,
			ui: this.ui,
			currTask: 'Backup',
			skipReset: true,
		});
		await qdl.run();
		this.ui.stdout.write(`Backing up NV data from device ${deviceId} complete!${os.EOL}`);
	}

	async restore({
		'input-dir': inputDir = process.cwd(),
		'log-dir': logDir = process.cwd(),
	} = {})	{
		if (!fs.existsSync(logDir)) {
			fs.mkdirSync(logDir, { recursive: true });
		}
		const deviceId = await this._getEDLDeviceId();
		const partitions = this.partitionDefinitions({ deviceId, dir: inputDir });
		this.verifyFilesExist(partitions);
		const xmlFile = this.generateXml({ partitions, operation: 'program' });
		const files = [
			this.firehosePath,
			xmlFile
		];
		this.ui.stdout.write(`Restoring NV data to device ${deviceId}...${os.EOL}`);
		const qdl = new QdlFlasher({
			outputLogFile: path.join(logDir, `tachyon_restore_${Date.now()}.log`),
			files: files,
			ui: this.ui,
			currTask: 'Restore',
			skipReset: true,
		});
		await qdl.run();
		this.ui.stdout.write(`Restoring NV data to device ${deviceId} complete!${os.EOL}`);
	}

	partitionDefinitions({ deviceId, dir }) {
		return PARTITIONS_TO_BACKUP.map((partition) => {
			return {
				...partition,
				filename: path.join(dir, `${deviceId}_${partition.label}.backup`)
			};
		});
	}

	generateXml({ partitions, operation }) {
		const xmlContent = this.getXmlContent({ partitions, operation });
		const tempFile = temp.openSync({ suffix: '.xml' });
		fs.writeSync(tempFile.fd, xmlContent, 0, xmlContent.length, 0);
		fs.closeSync(tempFile.fd);
		return tempFile.path;
	}

	getXmlContent({ partitions, operation = 'read' }) {
		const elements = partitions.map(partition => [
			`  <${operation}`,
			`    start_sector="${partition.start_sector}"`,
			`    physical_partition_number="${partition.physical_partition_number}"`,
			'    file_sector_offset="0"',
			`    num_partition_sectors="${partition.num_partition_sectors}"`,
			`    filename="${partition.filename}"`,
			'    sparse="false"',
			`    start_byte_hex="${partition.start_byte_hex}"`,
			'    SECTOR_SIZE_IN_BYTES="4096"',
			`    label="${partition.label}"`,
			'  />'
		].join('\n')).join('\n');
		const xmlLines = [
			'<?xml version="1.0" encoding="utf-8"?>',
			'<data>',
			'  <!--NOTE: This is an ** Autogenerated file **-->',
			elements,
			'</data>',
			''
		];
		return xmlLines.join('\n');
	}

	verifyFilesExist(partitions) {
		partitions.forEach((partition) => {
			if (!fs.existsSync(partition.filename)) {
				throw new Error(`File ${partition.filename} does not exist`);
			}
		});
	}

	async _getEDLDeviceId() {
		let edlDevices = [];
		let messageShown = false;
		while (edlDevices.length === 0) {
			try {
				edlDevices = await getEdlDevices();
				if (edlDevices.length > 0) {
					return edlDevices[0].id;
				}
				if (!messageShown) {
					this.ui.stdout.write(`Waiting for device to enter EDL mode...${os.EOL}`);
					messageShown = true;
				}
			} catch (error) {
				// ignore error
			}
			await delay(DEVICE_READY_WAIT_TIME);
		}
	}

};
