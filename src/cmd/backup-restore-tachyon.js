const CLICommandBase = require('./base');
const QdlFlasher = require('../lib/qdl');
const path = require('path');
const temp = require('temp').track();
const fs = require('fs-extra');
const { getEdlDevices } = require('particle-usb');
const os = require('os');
const { delay } = require('../lib/utilities');
const DEVICE_READY_WAIT_TIME = 5000;

module.exports = class BackupRestoreTachyonCommand extends CLICommandBase {
	constructor({ ui } = {}) {
		super();
		this.ui = ui || this.ui;
		this.firehoseDir = path.join(__dirname, '../../assets/qdl/firehose/prog_firehose_ddr.elf');
	}

	async backup({ 'output-dir': outputDir = process.cwd(), 'log-dir': logDir = process.cwd() } = {}) {
		const deviceId = await this._getEDLDeviceId();
		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}
		const xmlFile = this.generateXmlForRead({ outputDir, deviceId });
		const files = [
			this.firehoseDir,
			xmlFile
		];

		this.ui.stdout.write(`Backing up NV data from device ${deviceId}...${os.EOL}`);
		const qdl = new QdlFlasher({
			outputLogFile: path.join(logDir, `tachyon_backup_${Date.now()}.log`),
			files: files,
			ui: this.ui,
			currTask: 'Backup',
			skipReset: true,
		});
		await qdl.run();
		this.ui.stdout.write(`Backing up NV data from device ${deviceId} complete!${os.EOL}`);
	}

	generateXmlForRead({ deviceId, outputDir }) {
		const nv1Filename = path.join(outputDir,`${deviceId}_nvdata1.backup`);
		const nv2Filename = path.join(outputDir, `${deviceId}_nvdata2.backup`);
		const xmlContent = this.getReadWriteXmlContent({
			nv1Filename,
			nv2Filename,
			operation: 'read'
		});
		const tempFile = temp.openSync({ suffix: '.xml' });
		fs.writeSync(tempFile.fd, xmlContent, 0, xmlContent.length, 0);
		fs.closeSync(tempFile.fd);
		return tempFile.path;
	}

	async restore({
		'nvdata1-filename': nvdata1Filename,
		'nvdata2-filename': nvdata2Filename,
		'input-dir': inputDir = process.cwd(),
		'log-dir': logDir = process.cwd(),
	} = {}) {
		const deviceId = await this._getEDLDeviceId();
		const xmlFile = this.generateXmlForWrite({
			deviceId,
			nvdata1Filename,
			nvdata2Filename,
			inputDir
		});
		const files = [
			this.firehoseDir,
			xmlFile
		];
		this.ui.stdout.write(`Restoring NV data to device ${deviceId}...${os.EOL}`);
		const qdl = new QdlFlasher({
			outputLogFile: path.join(logDir, `tachyon_restore_${Date.now()}.log`),
			files: files,
			ui: this.ui,
			currTask: 'Restore',
			skipReset: true,
		});
		await qdl.run();
		this.ui.stdout.write(`Restoring NV data to device ${deviceId} complete!${os.EOL}`);
	}

	generateXmlForWrite({ deviceId, nvdata1Filename, nvdata2Filename, inputDir }) {
		const fileNames = [
			path.join(inputDir, `${deviceId}_nvdata1.backup`),
			path.join(inputDir, `${deviceId}_nvdata2.backup`)
		];

		const nv1Filename = nvdata1Filename || fileNames[0];
		const nv2Filename = nvdata2Filename || fileNames[1];
		const xmlContent = this.getReadWriteXmlContent({
			nv1Filename,
			nv2Filename,
			operation: 'program'
		});
		const tempFile = temp.openSync({ suffix: '.xml' });
		fs.writeSync(tempFile.fd, xmlContent, 0, xmlContent.length, 0);
		fs.closeSync(tempFile.fd);
		return tempFile.path;
	}

	getReadWriteXmlContent({ nv1Filename, nv2Filename, operation = 'read' }) {
		const nvdata = [
			{
				start_sector: 8,
				start_byte_hex: '0x8000',
				filename: nv1Filename,
				label: 'nvdata1'
			},
			{
				start_sector: 264,
				start_byte_hex: '0x108000',
				filename: nv2Filename,
				label: 'nvdata2'
			}
		];
		const elements = nvdata.map(read => [
			`  <${operation}`,
			`    start_sector="${read.start_sector}"`,
			'    size_in_KB="1024.0"',
			'    physical_partition_number="0"',
			'    partofsingleimage="false"',
			'    file_sector_offset="0"',
			'    num_partition_sectors="256"',
			'    readbackverify="false"',
			`    filename="${read.filename}"`,
			'    sparse="false"',
			`    start_byte_hex="${read.start_byte_hex}"`,
			'    SECTOR_SIZE_IN_BYTES="4096"',
			`    label="${read.label}"`,
			'  />'
		].join('\n')).join('\n');
		const xmlLines = [
			'<?xml version="1.0" encoding="utf-8"?>',
			'<data>',
			'  <!--NOTE: This is an ** Autogenerated file **-->',
			elements,
			'</data>',
			''
		];
		return xmlLines.join('\n');
	}

	async _getEDLDeviceId() {
		let edlDevices = [];
		let messageShown = false;
		while (edlDevices.length === 0) {
			try {
				edlDevices = await getEdlDevices();
				if (edlDevices.length > 0) {
					return edlDevices[0].id;
				}
				if (!messageShown) {
					this.ui.stdout.write(`Waiting for device to enter EDL mode...${os.EOL}`);
					messageShown = true;
				}
			} catch (error) {
				// ignore error
			}
			await delay(DEVICE_READY_WAIT_TIME);
		}
	}

};
